# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' test if adding a site can allow to reach the threshold with a given confidence
#' then choose the less expensive choice.
#'
#' @param viablesValues2 matrix of effects of introduction of each choice.
#' @param threshold number of sites colonised desired.
#' @param confidence desired confidence of reaching a certain number of sites
#' @param viablesTriplets link between sites&time and viablesValues2.
#' @param population total population of the current generation in the evolutionnary algorithm.
#' @param pop index of the studied individual of the population
#' @param current current probabilities of presence of the species at the end of the cycles, with the unchanged individual. 
NULL

#' (obsolete) test if removing each site can allow to still reach the threshold with a given confidence
#' then choose randomly to remove it from the individual.
#'
#' @param viablesValues2 matrix of effects of introduction of each choice.
#' @param threshold number of sites colonised desired.
#' @param confidence matrix of effects of introduction of each choice.
#' @param viablesTriplets link between sites&time and viablesValues2.
#' @param population total population of the current generation in the evolutionnary algorithm.
#' @param pop index of the studied individual of the population
#' @param current current probabilities of presence of the species at the end of the cycles, with the unchanged individual. 
half_random_add_site <- function(viablesValues2, threshold, confidence, viablesTriplets, population, pop, current) {
    .Call(`_IESTR_half_random_add_site`, viablesValues2, threshold, confidence, viablesTriplets, population, pop, current)
}

#' test if removing each site can allow to still reach the threshold with a given confidence
#' then choose the more expensive choice to remove it from the individual.
#'
#' @param viablesValues2 matrix of effects of introduction of each choice.
#' @param threshold number of sites colonised desired.
#' @param confidence matrix of effects of introduction of each choice.
#' @param viablesTriplets link between sites&time and viablesValues2.
#' @param population total population of the current generation in the evolutionnary algorithm.
#' @param pop index of the studied individual of the population
#' @param current current probabilities of presence of the species at the end of the cycles, with the unchanged individual. 
optimise_remove_site <- function(viablesValues2, threshold, confidence, viablesTriplets, population, pop, current) {
    .Call(`_IESTR_optimise_remove_site`, viablesValues2, threshold, confidence, viablesTriplets, population, pop, current)
}

optgenam3 <- function(currentPresenceMatrix, consecutiveSuitabilityMatrix, costMatrix, migrationKernel, threshold, confidence, npop, nsur, ngen) {
    .Call(`_IESTR_optgenam3`, currentPresenceMatrix, consecutiveSuitabilityMatrix, costMatrix, migrationKernel, threshold, confidence, npop, nsur, ngen)
}

#' return the probability that the number of success of Bernouillis event with probabilities given is between
#' zero and the given threshold 
#'
#' @param probabilityVector vector of probabilities for each bernouilli event considered.
#' @param threshold1 maximum value of success tested, inclued cases with more success.
NULL

#' return the evaluation of number of success like eval_probabilitVector, with two vector summed.
#'
#' @param probabilityVector first vector
#' @param probabilityVector2 second vector
#' @param threshold1 maximum value of success tested, inclued cases with more success.
NULL

#' get a random value between 0 & (j-1)
#'
#' @param j limit-1 of random value
NULL

#' generate a permutation.
#'
#' @param  vector of probabilities for each bernouilli event considered.
#' @param threshold1 maximum value of success tested, inclued cases with more success.
NULL

#' return the special matrix product between two probability matrix. (obsolete version)
#'
#' @param A first probability matrix
#' @param B second probability matrix
NULL

#' (obsolete version) return the special matrix product between two probability matrix.
#'
#' @param A first probability matrix
#' @param B second probability matrix
NULL

#' Set the random seed for C++ 
#'
#' @param seed seed value
rcpp_set_seed <- function(seed) {
    invisible(.Call(`_IESTR_rcpp_set_seed`, seed))
}

#' return random value from ununiform probability set. 
#'
#' @param ununiform_probabilities0 Rcpp vector of probabilities for each indices value
index_random_choice_non_uniform <- function(ununiform_probabilities0) {
    .Call(`_IESTR_index_random_choice_non_uniform`, ununiform_probabilities0)
}

#' return a permutation of numbers with ununiform probabilities of being chosen.
#'
#' @param permutation_size size of the permutation
#' @param ununiform_probabilities0 relative probabilities of being chosen
generate_permutation4 <- function(permutation_size, ununiform_probabilities0) {
    .Call(`_IESTR_generate_permutation4`, permutation_size, ununiform_probabilities0)
}

#' return the special matrix product between two probability matrix.
#'
#' @param A first probability matrix
#' @param B second probability matrix
proba_matrix_mult3 <- function(A, B) {
    .Call(`_IESTR_proba_matrix_mult3`, A, B)
}

#' Establishes from the consecutiveSuitabilityMatrix what are the
#' study sites in the map and attribute them an index used in 
#' other functions.
#' Warning : the indices start at 1.
#'
#' @param std::list<Eigen::SparseMatrix<double>> consecutiveSuitabilityMatrix
#' @return suitable sites as a sparse matrix
rcpp_global_suitable_sites <- function(consecutiveSuitabilityMatrix) {
    .Call(`_IESTR_rcpp_global_suitable_sites`, consecutiveSuitabilityMatrix)
}

#' Calculate the coordinates of the suitable sites.
#'
#' @param Eigen::SparseMatrix<double> globalSuitableSites
#' @return coordinates of the suitable sites as a matrix
rcpp_global_suitable_coordinates <- function(globalSuitableSites) {
    .Call(`_IESTR_rcpp_global_suitable_coordinates`, globalSuitableSites)
}

#' Calculate the spread_matrix
#'
#' @param Eigen::SparseMatrix<double> globalSuitableSites
#' @param Rcpp::NumericMatrix globalSuitableCoordinates
#' @param Rcpp::NumericMatrix migrationKernel
#' @return Product of v1 and v2
rcpp_spread_matrix <- function(globalSuitableSites, globalSuitableCoordinates, migrationKernel) {
    .Call(`_IESTR_rcpp_spread_matrix`, globalSuitableSites, globalSuitableCoordinates, migrationKernel)
}

#' Multiplies two doubles
#'
#' @param std::list<Eigen::SparseMatrix<double>> consecutiveSuitabilityMatrix
#' @param Eigen::SparseMatrix<double> localTransitionMatrix
#' @param Rcpp::NumericMatrix globalSuitableCoordinates
#' @return Product of v1 and v2
rcpp_local_transition_matrix <- function(consecutiveSuitabilityMatrix, localTransitionMatrix, globalSuitableCoordinates) {
    .Call(`_IESTR_rcpp_local_transition_matrix`, consecutiveSuitabilityMatrix, localTransitionMatrix, globalSuitableCoordinates)
}

rcpp_transition_matrix <- function(transitionMatrices) {
    .Call(`_IESTR_rcpp_transition_matrix`, transitionMatrices)
}

rcpp_viable_sites <- function(colonisationMatrices) {
    .Call(`_IESTR_rcpp_viable_sites`, colonisationMatrices)
}

rcpp_viable_triplets <- function(viableSites, colonisationMatrices, globalSuitableCoordinates, globalSuitableSites, costMatrix) {
    .Call(`_IESTR_rcpp_viable_triplets`, viableSites, colonisationMatrices, globalSuitableCoordinates, globalSuitableSites, costMatrix)
}

rcpp_viable_values <- function(viablesTriplets, viableSites, globalSuitableSites, colonisationMatrices) {
    .Call(`_IESTR_rcpp_viable_values`, viablesTriplets, viableSites, globalSuitableSites, colonisationMatrices)
}

rcpp_eval_current_prob <- function(threshold, currentPresenceMatrix, colonisationMatrices, globalSuitableSites) {
    .Call(`_IESTR_rcpp_eval_current_prob`, threshold, currentPresenceMatrix, colonisationMatrices, globalSuitableSites)
}

rcpp_pheromons <- function(viablesTriplets) {
    .Call(`_IESTR_rcpp_pheromons`, viablesTriplets)
}

rcpp_generate_population <- function(pheromons, globalSuitableSites, npop, nbtoplant) {
    .Call(`_IESTR_rcpp_generate_population`, pheromons, globalSuitableSites, npop, nbtoplant)
}

rcpp_algorithm_opt <- function(pheromons, viablesTriplets, population0, costMatrix, currentPresenceMatrix, colonisationMatrices, globalSuitableSites, viablesValues, threshold, confidence, npop, nsur, ngen, nbtoplant) {
    .Call(`_IESTR_rcpp_algorithm_opt`, pheromons, viablesTriplets, population0, costMatrix, currentPresenceMatrix, colonisationMatrices, globalSuitableSites, viablesValues, threshold, confidence, npop, nsur, ngen, nbtoplant)
}

rcpp_result_to_choice <- function(lastPopulation, viablesTriplets) {
    .Call(`_IESTR_rcpp_result_to_choice`, lastPopulation, viablesTriplets)
}

